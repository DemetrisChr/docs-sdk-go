= N1QL Queries from the SDK
:navtitle: N1QL from the SDK
:page-topic-type: howto
:page-aliases: n1ql-query

[abstract]
You can query for documents in Couchbase using the N1QL query language, a language based on SQL, but designed for structured and flexible JSON documents. 
Querying can solve typical programming tasks such as finding a user profile by email address, facebook login, or user ID.

WARNING: These pages cover the first _Developer Preview_ of the Couchbase Go SDK 2.0 (DP1).
As such they are likely to change without notice.
The DP1 code _should not_ be used in production.

Our query service uses N1QL, which will be fairly familiar to anyone who's used any dialect of SQL.
xref:#additional-resources[Further resources] for learning about N1QL are listed at the bottom of the page.
You may wish to  //// ............link Server N1QL intro pages.............
or just dive in with a query against our travel sample data set.
In this case, the one thing that you need to know is that in order to make a Bucket queryable, it must have at least one index defined.
You can define a _primary_ index on a bucket. 
When a primary index is defined you can issue non-covered queries on the bucket as well.

Use
xref:6.5@server::tools/cbq-shell.html[cbq], our interactive Query shell.
Open it, and enter the following:

[source,n1ql]
----
CREATE PRIMARY INDEX ON `travel-sample`
----

or replace _travel-sample_ with a different Bucket name to build an index on a different dataset.

NOTE: The default installation places cbq in `/opt/couchbase/bin/` on Linux, `/Applications/Couchbase Server.app/Contents/Resources/couchbase-core/bin/cbq` on OS X, and `C:\Program Files\Couchbase\Server\bin\cbq.exe` on Microsoft Windows.


== Queries & Placeholders

Placeholders allow you to specify variable constraints for an otherwise constant query. 
There are two variants of placeholders: postional and named parameters. 
Positional parameters use an ordinal placeholder for substitution and named parameters use variables. 
A named or positional parameter is a placeholder for a value in the WHERE, LIMIT or OFFSET clause of a query. 
Note that both parameters and options are optional.

.Positional parameter example:
[source,golang]
----
query := "SELECT x.* FROM `travel-sample` x WHERE x.`type`=$1 LIMIT 10;"
rows, err := globalCluster.Query(query, &QueryOptions{PositionalParameters: []interface{}{"hotel"}})
----

.Named parameter example:
[source,golang]
----
query := "SELECT x.* FROM `travel-sample` x WHERE x.`type`=$type LIMIT 10;"
params := make(map[string]interface{}, 1)
params["type"] = "hotel"
rows, err := globalCluster.Query(query, &QueryOptions{NamedParameters: params})
----

The complete code for this page's example can be found at xref:[??]


== Handling Results

In most cases your query will return more than one result, and you may be looking to iterate over those results:

[source,golang]
----
query := "SELECT x.* FROM `travel-sample` x WHERE x.`type`=$1 LIMIT 10;"
rows, err := globalCluster.Query(query, &QueryOptions{PositionalParameters: []interface{}{"hotel"}})

// check query was successful
if err != nil {
   panic(err)
}

// iterate over rows
var hotel interface{}   // this could also be a specific type like Hotel   
for rows.Next(&hotel) {
    fmt.Println(hotel)
}
----

== Scan Consistency


Setting a xref:????[staleness parameter for queries], with `scan_consistency`, enables a tradeoff between latency and (eventual) consistency.

* A N1QL query using the default *Not Bounded* Scan Consistency will not wait for any indexes to finish updating before running the query and returning results, meaning that results are returned quickly, but the query will not return any documents that are yet to be indexed.

* With Scan Consistency set to *RequestPlus*, all document changes and index updates are processed before the query is run.
Select this when consistency is always more important than performance.

* For a middle ground, *AtPlus* is a "read your own write" (RYOW) option, which means it just waits for the new documents that you specify to be indexed, rather than an entire index of multiple documents.
See the xref:scan-consistency-examples.adoc[examples] for how to use *AtPlus* for the best performance balance for many circumstances.

.ScanConsisteny (RYOW)
[source,golang]
----
// create / update document (mutation)
result, err := col.Upsert("id", struct {
    Name string `json:"name"`
    Type string `json:"type"`
}{Name: "somehotel", Type: "hotel"}, nil)
if err != nil {
    panic(err)
}

// create mutation state from mutation results
state := gocb.NewMutationState(result.MutationToken())

// use mutation state with query option
rows, err := cluster.Query("SELECT x.* FROM `travel-sample` x WHERE x.`type`=\"hotel\" LIMIT 10", &gocb.QueryOptions{
    ConsistentWith: state,
})
----

== Additional Resources

NOTE: N1QL is not the only query option in Couchbase.
Be sure to xref:??[check that your use case fits your selection of query service].

For a deeper dive into N1QL from the SDK, refer to our xref:[N1QL SDK concept doc].

The xref:[Server doc N1QL intro] and xref:[N1QL pages] make up a complete guide to the N1QL language, including all of the latest additions.

The xref:http://query.pub.couchbase.com/tutorial/#1[N1QL interactive tutorial] is a good introduction to the basics of N1QL use.

Indexes / GSI links?

SQL++ / Analytics.

